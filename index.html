<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Factory Defense — Conveyor Prototype (64x32 Animated)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <style>
    html,body{margin:0;height:100%;background:#1e1b1b;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #game{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
(() => {
  const W=1120, H=640;          // 화면 크기
  const TILE_W=64, TILE_H=32;   // 컨베이어 타일 그리드
  const BELT_SPEED = 90;        // 컨베이어 기본 속도(px/s) — 제품에 적용
  const PROD_FIRE_CD = 450;     // 제품 발사 간격(ms)

  // 방향 벡터(타일 기준)
  const DIRS = {
    R: {dx: 1, dy: 0, rot: 0},            // → (rotation 0)
    D: {dx: 0, dy: 1, rot: Math.PI/2},    // ↓
    L: {dx:-1, dy: 0, rot: Math.PI},      // ←
    U: {dx: 0, dy:-1, rot:-Math.PI/2}     // ↑
  };

  // 벨트 타입
  // straight: 직선, corner: 코너, cross: 교차
  // data = {type, dir:(R/L/U/D), turn:?}
  //  - 직선: dir만 사용 (R 또는 L 또는 U 또는 D)
  //  - 코너: dir는 '입력 방향', turn은 'R(우회전)/L(좌회전)'
  //  - 교차: type:'cross'
  class Main extends Phaser.Scene {
    constructor(){ super('main'); }

    preload(){
      // === 리소스 로딩 (여러분이 만드신 애니메이션 시트) ===
      this.load.spritesheet('belt', 'resources/tiles/conveyor.png',
        { frameWidth: TILE_W, frameHeight: TILE_H });
      this.load.spritesheet('belt_cross', 'resources/tiles/conveyor_cross.png',
        { frameWidth: TILE_W, frameHeight: TILE_H });

      // 임시 바닥/터렛/총알/적
      this.load.image('floor', 'resources/tiles/floor.png');
      this.load.image('product_turret', 'resources/sprites/product_turret.png');
      this.load.image('bullet', 'resources/effects/bullet.png');
      this.load.spritesheet('zombie', 'resources/sprites/zombie.png', {frameWidth:32, frameHeight:32});
    }

    create(){
      this.add.text(16,12,'Factory Defense — Conveyor Follow Prototype',{fontSize:16,color:'#fff'});

      // 애니메이션(프레임 0↔1)
      this.anims.create({ key:'beltRun', frames:[{key:'belt',frame:0},{key:'belt',frame:1}], frameRate:6, repeat:-1 });
      this.anims.create({ key:'beltCrossRun', frames:[{key:'belt_cross',frame:0},{key:'belt_cross',frame:1}], frameRate:6, repeat:-1 });

      // 바닥 타일 배경 (간단)
      for(let x=0;x<W;x+=TILE_W) for(let y=0;y<H;y+=TILE_H){
        this.add.image(x+TILE_W/2, y+TILE_H/2, 'floor').setAlpha(0.18);
      }

      // === 벨트 맵 구성 ===
      // 간단한 “직사각 루프 + 하단 입출력” 형태 (여러분 레이아웃에 맞춰 변경 가능)
      // grid 딕셔너리: key = gx,gy  (gx=x/64, gy=y/32)
      this.grid = new Map();
      const put = (gx,gy,data) => {
        const k = gx+','+gy;
        this.grid.set(k, data);
      };

      // 도우미: 화면 좌상단 그리드 기준 좌표 계산
      const toX = gx => gx*TILE_W + TILE_W/2;
      const toY = gy => gy*TILE_H + TILE_H/2;

      // 루프 사각형 범위
      const left=4, top=5, right=14, bottom=13; // 그리드 좌표(64x32)
      // 위/아래/좌/우 직선
      for(let gx=left; gx<=right; gx++){
        put(gx, top,   {type:'straight', dir:'R', sprite:this.placeBelt(toX(gx), toY(top), 'R')});
        put(gx, bottom,{type:'straight', dir:'L', sprite:this.placeBelt(toX(gx), toY(bottom), 'L')});
      }
      for(let gy=top; gy<=bottom; gy++){
        put(left,  gy, {type:'straight', dir:'D', sprite:this.placeBelt(toX(left), toY(gy), 'D')});
        put(right, gy, {type:'straight', dir:'U', sprite:this.placeBelt(toX(right),toY(gy), 'U')});
      }
      // 네 모서리 코너 (입력 방향 기준)
      put(left, top,     {type:'corner', dir:'U', turn:'R', sprite:this.placeCorner(toX(left), toY(top), 'U','R')});     // ↑→
      put(right, top,    {type:'corner', dir:'R', turn:'R', sprite:this.placeCorner(toX(right),toY(top),'R','R')});      // →↓
      put(right, bottom, {type:'corner', dir:'D', turn:'R', sprite:this.placeCorner(toX(right),toY(bottom),'D','R')});   // ↓←
      put(left, bottom,  {type:'corner', dir:'L', turn:'R', sprite:this.placeCorner(toX(left), toY(bottom),'L','R')});   // ←↑

      // 하단에 교차점 + 세로 라인 (예: OUT/IN 구간)
      const cx = Math.floor((left+right)/2);
      for(let gy=bottom+1; gy<=bottom+4; gy++){
        put(cx, gy, {type:'straight', dir:'D', sprite:this.placeBelt(toX(cx), toY(gy), 'D')});
      }
      put(cx, bottom, {type:'cross', sprite:this.placeCross(toX(cx), toY(bottom))});

      // === 물리/그룹 ===
      this.physics.world.setBounds(0,0,W,H);
      this.products = this.add.group();
      this.zombies  = this.physics.add.group();
      this.bullets  = this.physics.add.group();

      // 총알-좀비 충돌
      this.physics.add.overlap(this.bullets, this.zombies, (b,z)=>{ z.hp-=b.damage; b.destroy(); if(z.hp<=0){ z.destroy(); } });

      // === 스폰: 제품/좀비 테스트용 ===
      this.input.keyboard.on('keydown-P', ()=> this.spawnProduct(left, top));    // P: 제품 스폰(좌상단 진입)
      this.input.keyboard.on('keydown-Z', ()=> this.spawnZombie());              // Z: 좀비 스폰
      this.add.text(16, H-24, 'P: 제품 스폰  |  Z: 좀비 스폰',{fontSize:14,color:'#ddd'});

      // 주기적으로 좀비 생성
      this.time.addEvent({ delay: 2000, loop:true, callback:()=>this.spawnZombie() });
    }

    // 벨트 스프라이트 배치(직선)
    placeBelt(x,y,dir){
      const s = this.add.sprite(x,y,'belt',0).play('beltRun');
      s.setRotation(DIRS[dir].rot);
      return s;
    }
    // 코너
    placeCorner(x,y,dir,turn){
      // 코너는 시트 동일, 회전으로 처리(시각은 직선과 동일 사용)
      const s = this.add.sprite(x,y,'belt',0).play('beltRun');
      // 회전 기준: 코너 모양을 단순화(직선과 동일 스킨이지만 논리는 코너)
      // 필요하면 corner 전용 시트를 쓰도록 교체 가능
      return s;
    }
    // 교차
    placeCross(x,y){
      const s = this.add.sprite(x,y,'belt_cross',0).play('beltCrossRun');
      return s;
    }

    // 제품 스폰(gx,gy는 그리드 위치)
    spawnProduct(gx,gy){
      const x = gx*TILE_W + TILE_W/2;
      const y = gy*TILE_H + TILE_H/2;
      const p = this.physics.add.image(x,y,'product_turret').setDepth(3);
      p.setCircle(14, 2,2);
      p.setImmovable(true); // 수동 이동
      p.speed = BELT_SPEED;
      p.fireCd = 0;
      p.dir = {dx:1, dy:0}; // 초기값(타일에서 갱신)
      p.gridPrev = null;    // 이전 타일 키 (교차/코너 처리)
      this.products.add(p);
    }

    // 적 스폰(화면 양옆 랜덤)
    spawnZombie(){
      const side = Math.random()<0.5 ? 'L':'R';
      const x = side==='L' ? 40 : W-40;
      const y = Phaser.Math.Between(140, H-80);
      const z = this.physics.add.sprite(x,y,'zombie',0);
      z.play({key:'z_walk', frames:this.anims.generateFrameNumbers('zombie',{start:0,end:3}), frameRate:6, repeat:-1});
      z.setVelocityX(side==='L'? 40 : -40);
      z.hp = 30;
      this.zombies.add(z);
    }

    // 타일 조회
    getTileAtWorld(x,y){
      const gx = Math.floor(x / TILE_W);
      const gy = Math.floor(y / TILE_H);
      const k = gx+','+gy;
      return {gx,gy, data: this.grid.get(k), key:k};
    }

    // 교차에서의 진행 규칙: 직진 우선 → 우회전 → 좌회전(없으면 정지)
    chooseNextDir(dir, gx, gy){
      const order = [];
      // 직진
      order.push(dir);
      // 우회전/좌회전
      const rightTurn = {R:'D', D:'L', L:'U', U:'R'}[dir];
      const leftTurn  = {R:'U', U:'L', L:'D', D:'R'}[dir];
      order.push(rightTurn, leftTurn);
      for(const cand of order){
        const nx = gx + DIRS[cand].dx;
        const ny = gy + DIRS[cand].dy;
        const n = this.grid.get(nx+','+ny);
        if (!n) continue;
        if (n.type==='straight'){
          // 직선이 cand 방향과 일치해야 함
          if (n.dir===cand) return cand;
        } else if (n.type==='corner' || n.type==='cross'){
          // corner/cross는 언제나 진입 가능
          return cand;
        }
      }
      return dir; // fallback
    }

    update(_t, dtMs){
      const dt = dtMs/1000;

      // 제품 이동/사격
      this.products.getChildren().forEach(p=>{
        // 현재 타일 파악
        const info = this.getTileAtWorld(p.x, p.y);
        const tile = info.data;

        if (tile){
          // 방향 결정
          if (tile.type==='straight'){
            p.dir = DIRS[tile.dir];
          } else if (tile.type==='corner'){
            // corner: 입력 방향(tile.dir)에서 turn에 따라 회전
            // 현재 진입 방향이 tile.dir일 때만 회전. 아니라면 직전 방향 유지.
            const entering = p.gridPrev !== info.key; // 타일 처음 진입 시 처리
            if (entering){
              // 코너 규칙
              const rightTurn = {R:'D', D:'L', L:'U', U:'R'}[tile.dir];
              const leftTurn  = {R:'U', U:'L', L:'D', D:'R'}[tile.dir];
              const ndir = tile.turn==='R' ? rightTurn : leftTurn;
              p.dir = DIRS[ndir];
              p.gridPrev = info.key;
            }
          } else if (tile.type==='cross'){
            // 교차: 직진 우선 → 우회전 → 좌회전
            if (p._lastCross !== info.key){ // 교차 진입 시 1회 선택
              // p.dir이 없으면 기본 R
              const curr = (Object.keys(DIRS).find(k => DIRS[k]===p.dir)) || 'R';
              const ndir = this.chooseNextDir(curr, info.gx, info.gy);
              p.dir = DIRS[ndir];
              p._lastCross = info.key;
            }
          }
        }

        // 이동
        p.x += (p.dir.dx * p.speed) * dt;
        p.y += (p.dir.dy * p.speed) * dt;

        // 사격(간단히 가장 가까운 적)
        p.fireCd -= dtMs;
        if (p.fireCd<=0){
          const target = this.getNearestZombie(p.x,p.y, 160);
          if (target){
            this.fireBullet(p, target);
            p.fireCd = PROD_FIRE_CD;
          }
        }

        // 화면 밖으로 나가면 제거
        if (p.x<-40 || p.x>W+40 || p.y<-40 || p.y>H+40) p.destroy();
      });
    }

    getNearestZombie(x,y,range){
      let best=null, bestD=1e9;
      this.zombies.getChildren().forEach(z=>{
        if (!z.active) return;
        const d = Phaser.Math.Distance.Between(x,y,z.x,z.y);
        if (d<range && d<bestD){ best=z; bestD=d; }
      });
      return best;
    }

    fireBullet(p, target){
      const b = this.physics.add.image(p.x,p.y,'bullet');
      b.damage = 8;
      const dx=target.x-p.x, dy=target.y-p.y, len=Math.max(1,Math.hypot(dx,dy));
      const sp=360;
      b.setVelocity((dx/len)*sp, (dy/len)*sp);
      this.bullets.add(b);
      this.time.delayedCall(1500, ()=> b.destroy());
    }
  }

  new Phaser.Game({
    type: Phaser.AUTO, width: W, height: H, parent:'game',
    backgroundColor: '#231f1f',
    physics: { default:'arcade', arcade:{ debug:false } },
    scene: [Main]
  });
})();
</script>
</body>
</html>
